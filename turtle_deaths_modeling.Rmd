---
title: "Turtle deaths modeling"
output: html_notebook
---

I try to model turtle deaths at Raine Island by using a parametric function to determine missing counts.  They are only a few observations each season but the beginning (October 15) and end (April 30) of each season are assumed known. There is a peak during each season.  Different sections (sectors) are treated separately but assumed correlated. The state space of hatchling counts is modeled with an AR(1) process, where the slope (c) is modeled with a discrete Fourier series. 

```{r}
rm(list=ls())

library(tidyverse)
library(ggplot2)
library(lubridate)
library(readr)
library(reshape2)
library(jagsUI)
library(bayesplot)
source("Dunstan_functions.R")
```

Get the data. Then, create a dataframe containing complete season (DOSeason from 0 to 131) for each season. 

```{r}
col.def <- cols(Date = col_date(format = "%m/%d/%Y"),
                Heat = col_integer(),
                Cliff = col_integer(),
                Total = col_integer())

# Begin and end dates for each season
Day.begin <- "10-15"
Day.end <- "04-30"
# define nesting seasons - not the same as calendar years
# also define day of season, starts on 10-15

data.1 <- read_csv(file = "data/Turtle_deaths_with_zeros.csv",
                   col_types = col.def) %>%
  mutate(Year = year(Date),
         DOY = yday(Date),
         Season = ifelse(Date >= paste0(Year, "-", Day.end), 
                         Year, Year-1),
         Season.f = as.factor(Season), 
         DOS = as.numeric(Date - as.Date(paste0(Season, "-", Day.begin)))) %>%  
  group_by(Season.f) %>%
  mutate(Cum_Heat = cumsum(Heat),
         Cum_Cliff = cumsum(Cliff))

# find the number of days between Day1 and Day2
n.days <- as.numeric(as.Date(paste0("2018-", Day.end)) - as.Date(paste0("2017-", Day.begin)))

seasons <- unique(data.1$Season)

data.0 <- data.frame(Season = rep(seasons, each = n.days),
                     DOS = rep(seq(from = 1, to = n.days, by = 1), 
                                    times = length(seasons))) %>% 
  mutate(Date = as.Date(paste0(Season, "-", Day.begin)) + days(DOS))

data.0 %>% left_join(data.1, by = "Date") -> data.0.1

obs.y <- array(NA, c(length(seasons), 2, n.days))

for (i in 1:length(seasons)){
  obs.y[i, ,] <- t(filter(data.0.1, Season.x == seasons[i]) %>% 
                     select(c("Heat", "Cliff")))
  
}

MCMC.params <- list(n.chains = 4,
                    n.samples = 50000,
                    n.burnin = 10000,
                    n.thin = 5)

```

I have a tentative model that uses discrete a Fourier series with normal observation models to impute missing data.  Send these data to jags to fit the model. The DFS model crashes the computer... I think the data are just too sparse. 

Next... try the modified Richards function provided in Girondot et al. (2007).
Try first with non-log counts as it was done in their paper. Change the data format a little so that we are not "imputing" but estimating the parameters of the functions from data.

First, I fit the function to each cause of death separately. I first made K and S to vary among seasons. Some parameters didn't converge. So, I fixed K to be constant over seasons (flatness at the max value). Max values are different among seasons. 

# Heat related deaths

```{r}
n.seasons <- length(unique(data.1$Season))
max.days <- data.1 %>% 
  group_by(Season.f) %>% 
  summarise(total.days = max(DOS),
            n.days = n()) 

obs.y.1 <- array(data = NA, dim = c(n.seasons, max(max.days$n.days), 2))
obs.t <- matrix(NA, nrow = n.seasons, ncol = max(max.days$n.days))
n.vec <- P <- vector(mode = "numeric", length = n.seasons)
#season.sector.idx <- matrix(NA, nrow = length(Sectors) * length(seasons), ncol = 2)
#max.vec <- vector(mode = "numeric", length = length(seasons))
max.mat <- matrix(NA, nrow = length(seasons), ncol = 2)

season_idx <- cause_idx <- 1
for (season_idx in 1:n.seasons){
  data.1 %>% filter(Season == seasons[season_idx]) -> tmp
  n.vec[season_idx] <- nrow(tmp)
  P[season_idx] <- floor(max(tmp$DOS)/2)
  
  for (cause_idx in 1:2){
    
    if (nrow(tmp) > 0){
      obs.t[season_idx, 1:nrow(tmp)] <- tmp$DOS
      tmp2 <- ifelse(cause_idx == 1,
                     tmp[, "Heat"],
                     tmp[, "Cliff"])
      
      obs.y.1[season_idx, 1:nrow(tmp), cause_idx] <- unlist(tmp2)
      
      max.mat[season_idx, cause_idx] <- ifelse(cause_idx == 1,
                                               max(tmp$Heat, na.rm = T),
                                               max(tmp$Cliff, na.rm = T))
    }
    
  }
}

# first just run one at a time
jags.data.Heat <- list(y = (obs.y.1[,,1]),
                       t = obs.t,
                       P = P,
                       n.vec = n.vec,
                       n.seasons = n.seasons,
                       max.vec = max.mat[,1])
# 
jags.params <- c("sigma.y", "S", "K", "max",
                 "y", "X", "sigma.max", "deviance")
# 

if (!file.exists(paste0("RData/Richards_Heat_St_K_norm.rds"))){
  jm.1.Heat <- jags(jags.data.Heat,
             inits = NULL,
             parameters.to.save= jags.params,
             model.file = 'models/model_Richards_St_K_norm.txt',
             n.chains = MCMC.params$n.chains,
             n.burnin = MCMC.params$n.burnin,
             n.thin = MCMC.params$n.thin,
             n.iter = MCMC.params$n.samples,
             DIC = T, parallel=T)
  
  saveRDS(jm.1.Heat, paste0("RData/Richards_Heat_St_K_norm.rds"))
  
} else {
  jm.1.Heat <- readRDS(paste0("RData/Richards_Heat_St_K_norm.rds"))
}

mcmc_trace(jm.1.Heat$samples, c("sigma.y", "sigma.max"))

```

Seemed to work when using a constant K. 

```{r}
mcmc_trace(jm.1.Heat$samples, c("S[2]", "S[12]", "K"))
```

Let's look at the estimated functions. 

```{r}
X_Heat_St_K.df <- compute.summary.stats_St_K(jm.1.Heat$samples, 
                                               seasons, 
                                               max.days$total.days, 
                                               P)

ggplot() + 
  geom_path(data = X_Heat_St_K.df,
            aes(x = DOS, y = Med)) +
  geom_ribbon(data = X_Heat_St_K.df,
              aes(x = DOS, ymin = Low, ymax = High),
              alpha = 0.4) + 
  geom_point(data = data.1,
             aes(x = DOS, y = Heat)) + 
  facet_wrap(.~ as.factor(Season))

```

I think having a symmetrical function is a problem. It's possible that increases faster than decrease. 

What if we have only one S:

```{r}

if (!file.exists(paste0("RData/Richards_Heat_S_K_norm.rds"))){
  jm.2.Heat <- jags(jags.data.Heat,
             inits = NULL,
             parameters.to.save= jags.params,
             model.file = 'models/model_Richards_S_K_norm.txt',
             n.chains = MCMC.params$n.chains,
             n.burnin = MCMC.params$n.burnin,
             n.thin = MCMC.params$n.thin,
             n.iter = MCMC.params$n.samples,
             DIC = T, parallel=T)
  
  saveRDS(jm.2.Heat, paste0("RData/Richards_Heat_S_K_norm.rds"))
  
} else {
  jm.2.Heat <- readRDS(paste0("RData/Richards_Heat_S_K_norm.rds"))
}

mcmc_trace(jm.2.Heat$samples, c("sigma.y", "sigma.max"))

```


```{r}
X_Heat_S_K.df <- compute.summary.stats_S_K(samples = jm.2.Heat$samples, 
                                           seasons = seasons, 
                                           max.days = max.days$total.days, 
                                           P = P)

ggplot() + 
  geom_path(data = X_Heat_S_K.df,
            aes(x = DOS, y = Med)) +
  geom_ribbon(data = X_Heat_S_K.df,
              aes(x = DOS, ymin = Low, ymax = High),
              alpha = 0.4) + 
    geom_point(data = data.1,
             aes(x = DOS, y = Heat)) + 

  facet_wrap(.~ as.factor(Season))
```

According to DIC values, the first model is better:

```{r}
c(jm.1.Heat$DIC, jm.2.Heat$DIC)
```

But, we also need to do other model checking? Posterior predictive check may be a good one to do... 

# Cliff fall
Same can be done for cliff fall deaths:

```{r}
# first just run one at a time
jags.data.Cliff <- list(y = (obs.y.1[,,2]),
                       t = obs.t,
                       P = P,
                       n.vec = n.vec,
                       n.seasons = n.seasons,
                       max.vec = max.mat[,1])

if (!file.exists(paste0("RData/Richards_Cliff_St_K_norm.rds"))){
  jm.1.Cliff <- jags(jags.data.Cliff,
                     inits = NULL,
                     parameters.to.save= jags.params,
                     model.file = 'models/model_Richards_St_K_norm.txt',
                     n.chains = MCMC.params$n.chains,
                     n.burnin = MCMC.params$n.burnin,
                     n.thin = MCMC.params$n.thin,
                     n.iter = MCMC.params$n.samples,
                     DIC = T, parallel=T)
  
  saveRDS(jm.1.Ciff, paste0("RData/Richards_Cliff_St_K_norm.rds"))
  
} else {
  jm.1.Cliff <- readRDS(paste0("RData/Richards_Cliff_St_K_norm.rds"))
}


if (!file.exists(paste0("RData/Richards_Cliff_S_K_norm.rds"))){
  jm.2.Cliff <- jags(jags.data.Cliff,
                     inits = NULL,
                     parameters.to.save= jags.params,
                     model.file = 'models/model_Richards_S_K_norm.txt',
                     n.chains = MCMC.params$n.chains,
                     n.burnin = MCMC.params$n.burnin,
                     n.thin = MCMC.params$n.thin,
                     n.iter = MCMC.params$n.samples,
                     DIC = T, parallel=T)
  
  saveRDS(jm.2.Cliff, paste0("RData/Richards_Cliff_S_K_norm.rds"))
  
} else {
  jm.2.Cliff <- readRDS(paste0("RData/Richards_Cliff_S_K_norm.rds"))
}

mcmc_trace(jm.1.Cliff$samples, c("sigma.y", "sigma.max"))
```


```{r}
mcmc_trace(jm.2.Cliff$samples, c("sigma.y", "sigma.max"))
```

```{r}
X_Cliff_St_K_df <- compute.summary.stats_St_K(samples = jm.1.Cliff$samples, 
                                              seasons = seasons, 
                                              max.days = max.days$total.days, 
                                              P = P)

ggplot() + 
  geom_path(data = X_Cliff_St_K_df,
            aes(x = DOS, y = Med)) +
  geom_ribbon(data = X_Cliff_St_K_df,
              aes(x = DOS, ymin = Low, ymax = High),
              alpha = 0.4) + 
      geom_point(data = data.1,
             aes(x = DOS, y = Heat)) + 

  facet_wrap(.~ as.factor(Season))
```



```{r}
X_Cliff_S_K.df <- compute.summary.stats_S_K(samples = jm.2.Cliff$samples, 
                                           seasons = seasons, 
                                           max.days = max.days$total.days, 
                                           P = P)

ggplot() + 
  geom_path(data = X_Cliff_S_K.df,
            aes(x = DOS, y = Med)) +
  geom_ribbon(data = X_Cliff_S_K.df,
              aes(x = DOS, ymin = Low, ymax = High),
              alpha = 0.4) + 
     geom_point(data = data.1,
             aes(x = DOS, y = Heat)) + 
 facet_wrap(.~ as.factor(Season))
```

According to DIC values, the first model is better:

```{r}
c(jm.1.Cliff$DIC, jm.2.Cliff$DIC)
```
I created a modified version of the function by Girondot et al. In this model, I created two K parameters; one for increasing part and the other for decreasing part. Let's see how this model fits to the data/

# Heat with the new model
```{r}
jags.params <- c("sigma.y", "S", "K1", "K2", "max",
                 "y", "X", "sigma.max", "deviance")

if (!file.exists(paste0("RData/Richards_Heat_St_K1_K2_norm.rds"))){
  jm.3.Heat <- jags(jags.data.Heat,
                    inits = NULL,
                    parameters.to.save= jags.params,
                    model.file = 'models/model_Richards_St_K1_K2_norm.txt',
                    n.chains = MCMC.params$n.chains,
                    n.burnin = MCMC.params$n.burnin,
                    n.thin = MCMC.params$n.thin,
                    n.iter = MCMC.params$n.samples,
                    DIC = T, parallel=T)
  
  saveRDS(jm.3.Heat, paste0("RData/Richards_Heat_St_K1_K2_norm.rds"))
  
} else {
  jm.3.Heat <- readRDS(paste0("RData/Richards_Heat_St_K1_K2_norm.rds"))
}

if (!file.exists(paste0("RData/Richards_Heat_S_K1_K2_norm.rds"))){
  jm.4.Heat <- jags(jags.data.Heat,
                    inits = NULL,
                    parameters.to.save= jags.params,
                    model.file = 'models/model_Richards_S_K1_K2_norm.txt',
                    n.chains = MCMC.params$n.chains,
                    n.burnin = MCMC.params$n.burnin,
                    n.thin = MCMC.params$n.thin,
                    n.iter = MCMC.params$n.samples,
                    DIC = T, parallel=T)
  
  saveRDS(jm.4.Heat, paste0("RData/Richards_Heat_S_K1_K2_norm.rds"))
  
} else {
  jm.4.Heat <- readRDS(paste0("RData/Richards_Heat_S_K1_K2_norm.rds"))
}

```



```{r}
X_Heat_St_K1_K2.df <- compute.summary.stats_St_K1_K2(samples = jm.3.Heat$samples, 
                                                     seasons = seasons, 
                                                     max.days = max.days$total.days, 
                                                     P = P)

X_Heat_S_K1_K2.df <- compute.summary.stats_S_K1_K2(samples = jm.4.Heat$samples, 
                                           seasons = seasons, 
                                           max.days = max.days$total.days, 
                                           P = P)

```



```{r}
ggplot() + 
  geom_path(data = X_Heat_St_K1_K2.df,
            aes(x = DOS, y = Med)) +
  geom_ribbon(data = X_Heat_St_K1_K2.df,
              aes(x = DOS, ymin = Low, ymax = High),
              alpha = 0.4) + 
     geom_point(data = data.1,
             aes(x = DOS, y = Heat)) + 
 facet_wrap(.~ as.factor(Season))
```

```{r}
ggplot() + 
  geom_path(data = X_Heat_S_K1_K2.df,
            aes(x = DOS, y = Med)) +
  geom_ribbon(data = X_Heat_S_K1_K2.df,
              aes(x = DOS, ymin = Low, ymax = High),
              alpha = 0.4) + 
     geom_point(data = data.1,
             aes(x = DOS, y = Heat)) + 
 facet_wrap(.~ as.factor(Season))
```

```{r}
c(jm.1.Heat$DIC, jm.2.Heat$DIC, jm.3.Heat$DIC, jm.4.Heat$DIC)
```


# Cliff fall with the new model
```{r}

if (!file.exists(paste0("RData/Richards_Cliff_St_K1_K2_norm.rds"))){
  jm.3.Cliff <- jags(jags.data.Cliff,
                    inits = NULL,
                    parameters.to.save= jags.params,
                    model.file = 'models/model_Richards_St_K1_K2_norm.txt',
                    n.chains = MCMC.params$n.chains,
                    n.burnin = MCMC.params$n.burnin,
                    n.thin = MCMC.params$n.thin,
                    n.iter = MCMC.params$n.samples,
                    DIC = T, parallel=T)
  
  saveRDS(jm.3.Cliff, paste0("RData/Richards_Cliff_St_K1_K2_norm.rds"))
  
} else {
  jm.3.Cliff <- readRDS(paste0("RData/Richards_Cliff_St_K1_K2_norm.rds"))
}

if (!file.exists(paste0("RData/Richards_Cliff_S_K1_K2_norm.rds"))){
  jm.4.Cliff <- jags(jags.data.Cliff,
                     inits = NULL,
                     parameters.to.save= jags.params,
                     model.file = 'models/model_Richards_S_K1_K2_norm.txt',
                     n.chains = MCMC.params$n.chains,
                     n.burnin = MCMC.params$n.burnin,
                     n.thin = MCMC.params$n.thin,
                     n.iter = MCMC.params$n.samples,
                     DIC = T, parallel=T)
  
  saveRDS(jm.4.Cliff, paste0("RData/Richards_Cliff_S_K1_K2_norm.rds"))
  
} else {
  jm.4.Cliff <- readRDS(paste0("RData/Richards_Cliff_S_K1_K2_norm.rds"))
}

```



```{r}
X_Cliff_St_K1_K2.df <- compute.summary.stats_St_K1_K2(samples = jm.3.Cliff$samples, 
                                                      seasons = seasons, 
                                                      max.days = max.days$total.days, 
                                                      P = P)

X_Cliff_S_K1_K2.df <- compute.summary.stats_S_K1_K2(samples = jm.4.Cliff$samples, 
                                                    seasons = seasons, 
                                                    max.days = max.days$total.days, 
                                                    P = P)

```



```{r}
ggplot() + 
  geom_path(data = X_Cliff_St_K1_K2.df,
            aes(x = DOS, y = Med)) +
  geom_ribbon(data = X_Cliff_St_K1_K2.df,
              aes(x = DOS, ymin = Low, ymax = High),
              alpha = 0.4) + 
     geom_point(data = data.1,
             aes(x = DOS, y = Cliff)) + 
 facet_wrap(.~ as.factor(Season))
```



```{r}
ggplot() + 
  geom_path(data = X_Cliff_S_K1_K2.df,
            aes(x = DOS, y = Med)) +
  geom_ribbon(data = X_Cliff_S_K1_K2.df,
              aes(x = DOS, ymin = Low, ymax = High),
              alpha = 0.4) + 
     geom_point(data = data.1,
             aes(x = DOS, y = Cliff)) + 
 facet_wrap(.~ as.factor(Season))
```


```{r}
c(jm.1.Cliff$DIC, jm.2.Cliff$DIC, jm.3.Cliff$DIC, jm.4.Cliff$DIC)
```


Start here next... 2020-06-16




